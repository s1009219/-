# -*- coding: utf-8 -*-
"""AVL樹.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TeL1xfTXJRrMLnwqaSg5NNn_89eycE4l
"""

class AVLtree:
  def __init__(self, value):
    self.val = value
    self.left = self.right = None
    self.height = 1 #高度

  def getHeight(self, node):
    if node == None:
      return 0
    else:
      return node.height

  def updateHeight(self, node):
    #就是這段在模擬講義中的就是這段在模擬講義中的big()
    if self.getHeight(node.left) > self.getHeight(node.right):
      node.height = self.getHeight(node.left) + 1
    else:
      node.height = self.getHeight(node.right) + 1

  #以下就是以下就是LL、LR、RR、RL的實際程式做法的實際程式做法
  def LL(self, node):
    left = node.left
    lr = left.right
    left.right = node
    left.right.left = lr
    self.updateHeight(left.right)
    self.updateHeight(left)
    return left

  def RR(self, node):
    right = node.right
    rl = right.left
    right.left = node
    right.left.right = rl
    self.updateHeight(right.left)
    self.updateHeight(right)
    return right

  def LR(self, node):
    left = node.left
    lr = left.right
    lrl = lr.left
    lrr = lr.right
    lr.left = left
    lr.right = node
    lr.left.right = lrl
    lr.right.left = lrr
    self.updateHeight(lr.left)
    self.updateHeight(lr.right)
    self.updateHeight(lr)
    return lr

  def RL(self, node):
    right = node.rightBalance #右子樹
    rl = right.left #右子樹的左子樹
    rll = rl.left
    rlr = rl.right
    rl.left = node
    rl.right = right
    node.right = rll
    right.left = rlr
    self.updateHeight(rl.left)
    self.updateHeight(rl.right)
    self.updateHeight(rl)
    return rl

  #這兩個就是每次新增的時候，用來自動平衡的
  def leftBalance(self, node, x):
    if x < node.left.val:
      node = self.LL(node)
    else:
      node = self.LR(node)
    return node

  def rightBalance(self, node, x):
    if x < node.right.val:
      node = self.RL(node)
    else:
      node = self.RR(node)
    return node

  def addNode(self, node, x):
    if node != None:
      if node.val > x:
        node.left = self.addNode(node.left, x)

        #靠遞迴更新靠遞迴更新node之後，再判斷是否要左平衡
        if abs(self.getHeight(node.left) - self.getHeight(node.right)) == 2:
          node = self.leftBalance(node, x)
      else:
        node.right = self.addNode(node.right, x)

        #靠遞迴更新靠遞迴更新node之後，再判斷是否要右平衡
        if abs(self.getHeight(node.left) - self.getHeight(node.right)) == 2:
          node = self.rightBalance(node, x)
    else:
      node = AVLtree(x)
    self.updateHeight(node)
    return node

  def search(self, node, x):
    if node == None:
      return False
    if node.val == x:
      return True
    elif node.val > x:
      return self.search(node.left, x)
    else:
      return self.search(node.right, x)

  def inorder(self, node):
    if node != None:
      self.inorder(node.left)
      print(node.val, end=' ')
      self.inorder(node.right)
      
      
  def getBalance(self, node):
    if not node:
      return 0
    return self.getHeight(node.left) - self.getHeight(node.right)

  def minValueNode(self, node):
    current = node

    # loop down to find the leftmost leaf
    while(current.left is not None):
      current = current.left

    return current

  # Given a binary search tree and a key, this function
  # delete the key and returns the new root

  def delete(self, node, x):
    # Base Case
    if node is None:
      return node
    if x < node.val:
      node.left = self.delete(node.left, x)

    # If the kye to be delete
    # is greater than the root's key
    # then it lies in right subtree
    elif(x > node.val):
      node.right = self.delete(node.right, x)

    # If key is same as root's key, then this is the node
    # to be deleted
    else:

      # Node with only one child or no child
      if node.left is None:
        temp = node.right
        node = None
        return temp

      elif node.right is None:
        temp = node.left
        node = None
        return temp

      temp = self.minValueNode(node.right)
      node.val = temp.val
      node.right = self.delete(node.right,temp.val)

		# If the tree has only one node,
		# simply return it
    if node is None:
      return node

		# Step 2 - Update the height of the
		# ancestor node
    node.height = 1 + max(self.getHeight(node.left),
							self.getHeight(node.right))

		# Step 3 - Get the balance factor
    balance = self.getBalance(node)

		# Step 4 - If the node is unbalanced,
		# then try out the 4 cases
		# Case 1 - Left Left
    if balance > 1 and self.getBalance(node.left) >= 0:
      return self.rightBalance(node)

		# Case 2 - Right Right
    if balance < -1 and self.getBalance(node.right) <= 0:
      return self.leftBalance(node)

		# Case 3 - Left Right
    if balance > 1 and self.getBalance(node.left) < 0:
      node.left = self.leftBalance(node.left)
      return self.rightBalance(node)

		# Case 4 - Right Left
    if balance < -1 and self.getBalance(node.right) > 0:
      node.right = self.rightBalance(node.right)
      return self.leftBalance(ModuleNotFoundError)
    
    return node

root = AVLtree(10)
data = [5, 12, 3, 7, 1]
for i in range(len(data)):
  root = root.addNode(root, data[i])
  root.inorder(root)
  print()

for i in range(2):
  searchnum=int(input("Which number do you want to Find?"))
  print("After finding" ,searchnum," : ",root.search(root, searchnum))


deletenum=int(input("Which number do you want to Delete?"))
root.delete(root, deletenum)
print("Deleted",deletenum," ! ")
print("After finding ",deletenum," : ",root.search(root, deletenum))
print()
print("Inorder:")
print(root.inorder(root))